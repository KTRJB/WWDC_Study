
# what's new in swift 2023

## 새로운 기능

- Swift의 구문을 사용하여 의미를 더 쉽게 표현할 수 있는 방법
- 프레임워크 작성자가 새 API를 보다 자연스럽게 사용할 수 있는 기능
- 저수준 코드의 성능 및 안정성


## Expreesive code - 표현 방법(Swift의 변경 사항)

Swift5.9에서 if/else alc switch 문을 표현식으로 사용하여 코드를 정리할 수 있는 기능이 포함되어 있음.

<img width="775" alt="스크린샷 2023-07-20 오후 6 49 59" src="https://github.com/bradheo65/TIL/assets/45350356/fa2e75cb-4be9-43b6-8e17-4b6847f091a5">

예를 들어 복잡한 조건을 기반으로 let을 초기화 하려면 읽기 어려운 복합 삼항 연산자과 같은 트릭에 의존했어야 함.

<img width="787" alt="스크린샷 2023-07-20 오후 6 51 55" src="https://github.com/bradheo65/TIL/assets/45350356/87a2805f-2c1d-4dae-905c-8e061a555276">

if 표현식을 사용하면 훨씬 더 친숙하고 읽기 쉬운 if문의 체인으로 사용할 수 있음.

#### 도움이 되는 또 다른 경우는 전역 변수 또는 저장 프로퍼티를 초기화하는 경우

<img width="781" alt="스크린샷 2023-07-20 오후 6 53 47" src="https://github.com/bradheo65/TIL/assets/45350356/08998bef-f584-407f-ad92-d0d142d2195e">

조건을 원하는 경우 클로저 트릭을 사용했어야 했음.

![](https://hackmd.io/_uploads/By_PVFU52.png)

이제 if문이 표현식이 될 수 있으므로 복잡함을 없애고 더 깔끔한 코드를 남길 수 있게 됨

<img width="763" alt="스크린샷 2023-07-20 오후 6 55 11" src="https://github.com/bradheo65/TIL/assets/45350356/2485a3d0-f621-40f6-8315-66098c7b673b">


### 개선 사항 - 1. SwiftUI와 같은 기능을 구동하는 선언적 구문인 결과 빌더

- 유형 검사 성능
- 코드 완성 및 향상된 오류 메세지

이번 개선 사항은 특히 유효하지 않은 코드에 중점을 둠

이전에는 오류가 있는 결과 빌더 코드가 실패하는 데 오랜 시간이 걸렸음. 그 이유는 유형 검사기가 가능한 많은 유효하지 않은 경로를 탐색했기 때문임.

이제 Swift5.8부터 오류 검사가 빨라 졌으며, 유효하지 않은 코드에 대한 오류 메세지는 더욱 정확해짐.

예를 들어 이전에는 일부 유효하지 않은 코드로 인해 결과 빌더 다른 부분에서 잘못된 오류가 발생되었음.

실제로 Swift5.7에서 아래 사진처럼 오류를 발생시킴

<img width="780" alt="스크린샷 2023-07-20 오후 6 59 18" src="https://github.com/bradheo65/TIL/assets/45350356/fcf4df1e-4174-4bee-9873-96127639d4c8">

이제는 실제 문제를 식별할 수 있는 정확한 컴파일러 진단을 받을 수 있게 

<img width="788" alt="스크린샷 2023-07-20 오후 7 00 47" src="https://github.com/bradheo65/TIL/assets/45350356/3b57ce8c-95e0-438f-97ef-e67758e9ac59">


### 개선 사항 - 2. 프레임워크 개선 - 제네릭 시스템

모든 Swift는 어떤식으로든 제네릭을 사용하고 있음.

예를 들어, 형식 유추를 사용하면 이러한 형식이 내장된 고급 기능을 이해할 필요 없이 사용할 수 있음.

또한 표준 라이브러리의 배열 유형은 제네릭을 사용하면 저장하려는 모든 유형의 데이터와 함께 작동하는 배열을 제공

<img width="737" alt="스크린샷 2023-07-20 오후 7 03 14" src="https://github.com/bradheo65/TIL/assets/45350356/2b908fc7-6c37-4829-8f99-c586bb8d6360">

배열을 사용할 떄는 오로지 요소만 제공하면 됨.

요소 값에서 이미 유형을 유추할 수 있음.

<img width="748" alt="스크린샷 2023-07-20 오후 7 03 56" src="https://github.com/bradheo65/TIL/assets/45350356/5be5df92-2266-425b-a830-48aefe8404f5">

Swift 컴파일러의 자체 코드베이스의 예

요청 유형을 사용하고 이를 평가하여 강력한 유형의 값을 생성하는 API 입니다.

<img width="786" alt="스크린샷 2023-07-20 오후 7 06 31" src="https://github.com/bradheo65/TIL/assets/45350356/4d1ce807-2e9b-4818-b78e-19d1fe94570f">

따라서 Bool 값을 요청하고 Bool값을 반환할 수 있음.

이제 추상화 했을 때, 함수는 하나의 요청을 받고 하나의 결과를 반환하거나 계속 요청할 갯수만큼 결과를 반환할 수 있습니다.

![](https://hackmd.io/_uploads/HJnDvFL9h.png)

이를 지원하려면 전달하는 모든 형식이 내보내는 형식이 연결되도록 여러 인수 길이를 처리하는 메커니즘과 함께 제네릭 시스템을 사용해야함.

Swift5.9이전에는 각 인수 길이에 대한 오버로드를 추가하는 것이였음.

<img width="769" alt="스크린샷 2023-07-20 오후 7 09 06" src="https://github.com/bradheo65/TIL/assets/45350356/19e47bb1-b8b7-4312-b22b-a1d991366e7c">

하지만 이 방법은 별로임.

너무 많이 전달할 시 컴파일러 오류가 발생됨

이 경우엔 6개 이상의 인수를 처리할 수 있는 오버로드가 없지만 7개를 전달해 발생됨.

<img width="769" alt="스크린샷 2023-07-20 오후 7 10 21" src="https://github.com/bradheo65/TIL/assets/45350356/8b1b53be-9779-47c6-bb56-f5cb588711c4">

이제 Swift5.9에서 제네릭 시스템은 인수 길이에 대한 제네릭 추상화를 활성화하여 이 API 패턴에 대한 자원을 얻고 있음.

<img width="723" alt="스크린샷 2023-07-20 오후 7 11 55" src="https://github.com/bradheo65/TIL/assets/45350356/0ff26b79-48cb-4d07-bff1-b0f043426d79">
b1b53be-9779-47c6-bb56-f5cb588711c4">

이것은 함께 "패키징"되는 여러 개별 유형 매개변수를 나타낼 수 있는 새로운 언어 개념으로 수행됨.

이 새로운 개념을 "유형 매개변수 팩"이라고 함.

매개변수 팩을 사용하게 되면 각 고정 인수 길이에 대한 개별 오버로드가 있는 API를 단일 함수로 축소 시킬 수 있게 됨.

<img width="776" alt="스크린샷 2023-07-20 오후 7 14 03" src="https://github.com/bradheo65/TIL/assets/45350356/c64870cf-4d9b-423e-bac8-1a2c3686ad8f">

Result를 수락하는 대신 평가 함수는 각 Result 유형에 대해 별도의 요청을 수락함.

이 함수는 단일 값 또는 가 값을 포함하는 튜플인 괄호 안에 결과 인스턴를 반환하게 됨.

이제 평가 함수는 인공 제한 없이 모든 인수 길이를 처리함

이제 매개변수 팩을 사용하는 API는 API를 사용하고 있는지 알 필요 없이 자연스럽게 사용할 수 있도록함.

인수를 처리할 때 고정 길이 오버로드를 호출하는 것과 같은 효과를 보게 됨

<img width="781" alt="스크린샷 2023-07-20 오후 7 17 53" src="https://github.com/bradheo65/TIL/assets/45350356/dddaf4ce-5597-4589-9b27-e7405153b818">
">

Swift는 함수를 호출하는 방법에 따라 총 개수와 함께 각 인수의 유형을 추론.

이와 같은 일반 가이브러리 API를 작성하는 방법에 대해 알아보려면 매개변수 팩을 사용하여 API 일반화를 확인이 필요.

자연스러운 방식으로 일반 API를 호출하는 것이 Swift의 기본 설계 목표 중 하나인 간결한 코드를 통한 명확한 표현을 보여줌.

Swift의 고급 언어 기능은 당신이 의미하는 바를 더 쉽게 말하 수 있게 해주는 아름다운 API를 가능하게 해줍니다.

배열, 사전을 통해 제네릭을 사용하든 SwiftUI에서 UI를 디자인 하든 Swift의 첫 줄에서 이러한 고급 언어 기능을 누릴 수 있음.

Swift5.9는 라이브러리 작성자에게 새로운 매크로 시스템을 사용하여 표현적인 API디자인을 위한 새로운 도구 상자를 제공하면서, 다음 디자인 접근 방식을 끌어 올리게함.

<img width="718" alt="스크린샷 2023-07-20 오후 7 23 00" src="https://github.com/bradheo65/TIL/assets/45350356/c87c8bb4-2f1b-4028-a5cb-8cbcc1cea7fc">

매크로를 사용하면 언어 자체의 기능을 확장해 상용구를 제거하고 Swift의 표현력을 더 많이 활용할 수 있게 됨.

assert 함수를 생각해보자.

Assert는 조건이 거짓이면 프로그램을 중지하게 되지만 그런 경우 무엇이 잘못되었는지 거의 얻지 못함. 파일과 줄 번호만 얻게 됨.

<img width="762" alt="스크린샷 2023-07-20 오후 7 25 06" src="https://github.com/bradheo65/TIL/assets/45350356/50518c83-b982-41eb-8a69-0438039ff5a6">

자세히 알라볼려면 디버거에서 로깅을 추가하거나 프로그램을 트랩해야함.

이를 개선하려는 시도.

XCTest는 두 값을 개별적으로 사용하는 assert-equal 작업을 제공해, 문제가 발생하면 두 값이 같지 않을 것을 볼 수 있음.

<img width="762" alt="스크린샷 2023-07-20 오후 7 26 34" src="https://github.com/bradheo65/TIL/assets/45350356/7388b126-701c-4046-bf55-4f91be0e3d04">

그러나 여전히 어떤 값이 잘못되었는지 알 수 가 없음.

다시 assert로 돌아가면 소스 코드에는 실패할 때 보고 싶은 로그들이 많음.

Swift에서는 이를 개선할 수 없었지만 매크로를 사용하면 가능함.

앞에 #(hash)을 추가해 매크로를 확장.

<img width="797" alt="스크린샷 2023-07-20 오후 7 28 44" src="https://github.com/bradheo65/TIL/assets/45350356/746ec64b-64d1-433c-9b07-6b67fb375759">

![](https://hackmd.io/_uploads/B1YYnKUcn.png)

이제 더 풍부한 오류 로그들을 볼 수 있게 됨.

Swift에서 매크로는 유형이나 함수와 마찬가지로 API이므로 매크로를 정의하는 모듈을 가져와 액세스 하게 됨.

<img width="776" alt="스크린샷 2023-07-20 오후 7 30 39" src="https://github.com/bradheo65/TIL/assets/45350356/74621c3d-7952-40b7-bf89-89801b41dca8">

여기서 assert 매크로는 Swift 오픈 소스 패키지인 power asserts 라이브러리에서 가져옴

해당 라이브러리에서 assert을 확인할 수 있음.

여기서 확인할 조건에 대해 레이블이 지정되지 않은 단일 Bool 매개변수가 있는데, 이 매크로가 값을 생성하면 화살표 구문으로 작성됨.

매크로의 사용은 매개변수에 대해 유형이 검사함.

즉, 최대값을 무언가와 비교하는 것을 잊는 등 매크로를 사용하면서 실수를 한 경우 즉시 오류 메세지를 호출함.

<img width="787" alt="스크린샷 2023-07-20 오후 7 34 24" src="https://github.com/bradheo65/TIL/assets/45350356/27528eda-3b0d-4137-9d03-23e4537bdee1">

사전에 실수를 방지할 수 있어 좋은 개발 경험..

대부분의 매크로는 문자열을 통해 매크로 구현을 위한 모듈 및 유형을 지정하는 "외부 매크로"로 정의됨.

외부 매크로 유형은 컴파일러 플러그인 역활을 하는 별도의 프로그램에서 정의되는데,

Swift 컴파일러는 매크로 사용을 위한 소스 코드를 플러그인에 전달하고, 플러그인은 새로운 소스 코드를 생성한 다음 Swift 프로그램에 다시 통합시킴

<img width="760" alt="스크린샷 2023-07-20 오후 7 36 14" src="https://github.com/bradheo65/TIL/assets/45350356/98fff7db-5a57-4385-bc2e-0ee6a04b5c2a">

여기서 assert 매크로는 독립된 식 매크로라고 하는데,

"해시"구문을 사용하고 해당 구문에서 직접 작동하여 새 코드를 생성하기 때문에 독립형이라고 하고, 값을 생성할 수 있는 모든 곳에서 사용할 수 있기 때문에 식 매크로라고 함.

<img width="775" alt="스크린샷 2023-07-20 오후 7 39 11" src="https://github.com/bradheo65/TIL/assets/45350356/8aeefa4b-e720-4f1b-bdf4-36aca922f89a">
b-5a57-4385-bc2e-0ee6a04b5c2a">

새로운 Foundation PredicateAPI는 표현식 매크로의 좋은 예임.

조건자 매크로를 사용하게 되면 클로저를 사용해 형식이 안전한 방식으로 조건자를 작성할 수 있게 됨.

결과 조건자 값은 Swift 컬렉션 작업인 SwiftUI 및 SwiftData를 포함하여 여러 다른 API와 함께 사용할 수 있음.

<img width="781" alt="스크린샷 2023-07-20 오후 7 41 58" src="https://github.com/bradheo65/TIL/assets/45350356/0e4eda51-22a9-451b-9c78-08771770b58a">


매크로 자체는 입력 유형 집합에 대해 일반적..

해당 입력 유형의 값에 대해 클로저 인수를 허용하고 Bool결과를 생성하고, 그리고 매크로는 프로그램의 다른 곳에서 사용할 수 있는 새로운 Predicate 유형의 인스턴스를 반환함.

<img width="778" alt="스크린샷 2023-07-20 오후 7 43 48" src="https://github.com/bradheo65/TIL/assets/45350356/6be10d56-6fb9-4d60-a0be-f62bc5ec96ae">

그러나 매크로에는 더 많은 것들이 있는데, 왜냐하면 작성하게 되는 많은 상용구는 다른 것으로 보강해야 하기 떄문임.

예를 들면...

상대 또는 절대 경로를 캡쳐하는 이 Path는 코드 내 열거형을 많이 사용한다는 것을 알게 됨.

그러나 컬렉션에서 모든 절대 경로를 필터링하여 특정 사례를 확인해야 하는 경우가 종종 있음.

<img width="772" alt="스크린샷 2023-07-20 오후 7 47 03" src="https://github.com/bradheo65/TIL/assets/45350356/79812031-b5bb-4f24-9216-c931ba54d023">

매크로를 사용하여 도움이 줄 수 있음.

코드를 생성함

<img width="807" alt="스크린샷 2023-07-20 오후 7 47 54" src="https://github.com/bradheo65/TIL/assets/45350356/c6421606-5f89-49f9-bb2f-5e8dee099aa8">

매크로 규칙들..

<img width="764" alt="스크린샷 2023-07-20 오후 7 48 30" src="https://github.com/bradheo65/TIL/assets/45350356/f890f37c-0ef1-41c4-bca5-43b37dfa401c">

피어 매크로
- 예를 들어 비동기 메서드의 완료 처리기 버전을 생성하거나 그 반대로 생성하기 위해 연결된 선언과 함께 새 선언을 추가합니다.

접근자 매크로
- 저장된 속성을 계산된 속성으로 전환할 수 있으며 속성 액세스에 대한 특정 작업을 수행하거나 속성 래퍼와 비슷하지만 더 유연한 방식으로 실제 저장소를 추상화하는 데 사용할 수 있습니다.

첨부된 매크로
- 유형의 특정 멤버에 속성을 도입할 수 있을 뿐만 아니라 새로운 프로토콜 적합성을 추가할 수 있습니다.


연결된 여러 매크로 역할을 함께 구성하여 유용한 효과를 얻을 수 있음.


SwiftUI 매크로 예

기존에는 Published라는 키워드를 써야 했는데...

<img width="777" alt="스크린샷 2023-07-20 오후 7 53 11" src="https://github.com/bradheo65/TIL/assets/45350356/eb7cd669-c70f-4052-a5d0-635050d2da52">


매크로를 쓰게 되면 모든 저장된 속성을 관찰할 수 있게 됨.

<img width="750" alt="스크린샷 2023-07-20 오후 7 52 53" src="https://github.com/bradheo65/TIL/assets/45350356/550e843d-0131-4697-bc56-ffad66ec349c">

Observalbe 매크로는 세 가지 매크로 역활의 구성을 통해 작동됨

<img width="769" alt="스크린샷 2023-07-20 오후 7 54 08" src="https://github.com/bradheo65/TIL/assets/45350356/0491b7df-8a84-4bb5-a007-99da42a83660">

매크로 확장 코드를 볼려면 "매크로 확장"작업을 사용

### 정리

- Swift 매크로는 표현력이 풍부한 API를 사용하고 코드에서 상용구를 제거해 표현력을 올릴 수 있는 새로운 도구를 제공
- 쉽게 추론 가능.


## Swift everywhere

- 확장 가능한 언어로 설계
- 효율적
- C 또는 C++를 사용해야 했던 저수준 시스템으로 Swift를 푸시할 수 있음

### Foundation 리팩토링

#### 성능 향상

- Calendar 20%
- Date formatting 150%
- JSON 디코딩 200 ~ 500 %

-> Objective-C와 Swift의 연결 비용 개선

벤치마크 비교

<img width="776" alt="스크린샷 2023-07-20 오후 8 05 05" src="https://github.com/bradheo65/TIL/assets/45350356/eb89b5b4-b59c-4463-a219-16add6416432">
-4052-a5d0-635050d2da52">

#### 새로운 기능

- 낮은 수준의 시스템에서 작동할 때 필요한 수준의 성능을 달성하기 위해 도입

##### 옵트인 - 소유권 개념

값을 전달할 때 코드의 어떤 부분이 값을 소유 하는지에 대한 초점

실수 예제

- 유형이 범위를 벗어나기 전 close 메소드를 호출해야함. 항상 수동으로

![](https://hackmd.io/_uploads/Hk0hHcUc2.png)

이를 해결하기 위해 또 다른 추가 메모리 할당을 해야 할 수 도 있음.

<img width="745" alt="스크린샷 2023-07-20 오후 8 09 55" src="https://github.com/bradheo65/TIL/assets/45350356/172fa2e4-cf06-44e4-966d-a2596ba9cb3f">

근본적인 해결책은 이 구조체의 복사본을 만드는 기능을 억제하는 것

새로운 기능인 Copyable을 쓰게 되면 클래스와 마찬가지로 deinit을 지정할 수 있게 됨

<img width="767" alt="스크린샷 2023-07-20 오후 8 12 23" src="https://github.com/bradheo65/TIL/assets/45350356/88678d50-46e4-4dc8-9186-d888609d1c83">

### 정리

- 복사할 수 없는 유형은 강력한 새 기능임.
- 계속해서 확장할 거임


## Swift의 핵심은 Objective-C와 상호 운용성

Swift에서 직접 C++ 유형 및 함수와 상호 작용하는 기능을 도입

Swift 컴파일러는 이제 일반적인 C++ 관용구를 이해하므로 많은 유형을 직접 사용할 수 있음.

아래의 예는 C++ 값 유형에서 Swift 값 유형을 ㅗ취급하고 올바른 특수 멤버 함수를 자동으로 호출함.

그리고 간단한 Swift 코드를 작성할 수도 있음.

<img width="775" alt="스크린샷 2023-07-20 오후 8 20 43" src="https://github.com/bradheo65/TIL/assets/45350356/ff5a6ffd-1262-4c88-af72-abc485eac5db">


### 정리

- Swift의 C++ 상호 운용성은 Swift를 기존 C++ 코드 베이스와 통합하는 것을 쉽게 만듬.
- 직접 표현할 수 있게 지만 떄떄로 일부 주석이 필요할 수 도 있음.
- Swift API는 C++에서 직접 액세스할 수 있음.

### CMake

하지만 기존 빌드 시스템을 SPM으로 교체하여 다시 시작하는 것이 어려울 수도 있는데. 이를 개선하기위해 CMake와 협력함

<img width="744" alt="스크린샷 2023-07-20 오후 8 24 25" src="https://github.com/bradheo65/TIL/assets/45350356/22f86225-81c3-4e7d-a68c-6db71a3340f9">

Swift 코드를 Cmake빌드에 통합할 수 있고, 적절한 지원 라이브러리 및 런타임을 연결함

## Actors and concurrency

대표적으로 actor, Task가 있는데, 이 두가지는 추상 언어 모델에 통합되지만, 해당 모델 내에서 다양한 환경에 맞게 다양한 방식으로 구현될 수 있음.

<img width="790" alt="스크린샷 2023-07-20 오후 8 31 10" src="https://github.com/bradheo65/TIL/assets/45350356/68c729f5-4ebd-4b56-9eeb-3e674e525878">

Apple플랫폼의 경우 Dispatch라이브러리는 전체 운영 체제에 최적화된 일정을 제공하며 각 플랫폼에 대해 광범위하게 조정됨

Swift의 동시성 모델은 단일 스레드 협력 대기열로 구현됨

런타임 환경에 매핑할 수 있을 만큼 유연하기에 Swift 코드가 두 환경에서 모두 작동됨.

또한 콜백 기반 라이브러와의 상호운윤용성은 처음부터 async/await지원이 내장되어 있으며 withCheckedContinuation 작업을 통해 작업을 일시 중지 후 나중에 실행할 수 있음.

이를 통해 기존 라이브러리와의 통합이 가능해짐.

## FoundationDB

- 상용 하드웨어에서 실행되고 MacOS, Linux 및 Windows를 포함한 다양한 플랫폼을 지원하는 매우 큰 키-값 저장소를 위한 확장 가능한 솔루션을 제공하는 분산 데이터베이스

- C++로 작성된 대규모 코드 베이스가 포함된 오픈 소스 프로젝트

- 코드는 테스트 목적으로 매우 중요한 결정론적 시뮬레이션 환경을 제공하는 고유한 형태의 분산 액터 및 런타임을 사용하여 매우 비동기적


FoundationDB는 코드 기반을 현대화하려고 했고 Swift가 성능, 안전 및 코드 명확성에 적합하다는 해 완전한 재 작성은 크고 위험함

-> 대신 Swift의 상호 운용성을 활용하여 기존 코드 베이스에 통합


# 정리

1. 보다 표현력이 풍부한 API를 지원하고 더 나은 코드를 더 빠르게 작성하는 데 도움이 되는 매개변수 팩 및 매크로와 같은 기능에 대해 설명

2. 성능에 민감한 코드에서 Swift를 사용하는 것과 복사할 수 없는 유형을 도입하여 참조 횟수 오버헤드 없이 리소스 관리를 제공하는 것에 대해 고민

4. Swift의 유연한 동시성 모델이 동시성을 보다 쉽고 안전하게 만들기 위해 여러 장치와 언어에 걸쳐 무수한 환경에 어떻게 적용하는 방법